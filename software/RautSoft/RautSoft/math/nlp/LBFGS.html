<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Sun May 01 03:29:16 PDT 2005 -->
<TITLE>
LBFGS (RautSoft Economics and Business Numerics)
</TITLE>

<META NAME="keywords" CONTENT="RautSoft.math.nlp.LBFGS class">
<META NAME="keywords" CONTENT="gtol">
<META NAME="keywords" CONTENT="stpmin">
<META NAME="keywords" CONTENT="stpmax">
<META NAME="keywords" CONTENT="solution_cache">
<META NAME="keywords" CONTENT="nfevaluations()">
<META NAME="keywords" CONTENT="lbfgs()">
<META NAME="keywords" CONTENT="lb1()">
<META NAME="keywords" CONTENT="daxpy()">
<META NAME="keywords" CONTENT="ddot()">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="LBFGS (RautSoft Economics and Business Numerics)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
RautSoft Economics and Business Numerics</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../RautSoft/math/nlp/DonlpJava.html" title="class in RautSoft.math.nlp"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../RautSoft/math/nlp/LBFGS.ExceptionWithIflag.html" title="class in RautSoft.math.nlp"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?RautSoft/math/nlp/LBFGS.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="LBFGS.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
RautSoft.math.nlp</FONT>
<BR>
Class LBFGS</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>RautSoft.math.nlp.LBFGS</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>LBFGS</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
<p> This class contains code for the limited-memory Broyden-Fletcher-Goldfarb-Shanno
 (LBFGS) algorithm for large-scale multidimensional unconstrained minimization problems.
 This file is a translation of Fortran code written by Jorge Nocedal.
 The only modification to the algorithm is the addition of a cache to
 store the result of the most recent line search. See <tt>solution_cache</tt> below.

 LBFGS is distributed as part of the RISO project. Following is a message from Jorge Nocedal:
 <pre>
   From: Jorge Nocedal [mailto:nocedal@dario.ece.nwu.edu]
   Sent: Friday, August 17, 2001 9:09 AM
   To: Robert Dodier
   Subject: Re: Commercial licensing terms for LBFGS?

   Robert:
   The code L-BFGS (for unconstrained problems) is in the public domain.
   It can be used in any commercial application.

   The code L-BFGS-B (for bound constrained problems) belongs to
   ACM. You need to contact them for a commercial license. It is
   algorithm 778.

   Jorge
 </pre>

 <p> This code is derived from the Fortran program <code>lbfgs.f</code>.
 The Java translation was effected mostly mechanically, with some
 manual clean-up; in particular, array indices start at 0 instead of 1.
 Most of the comments from the Fortran code have been pasted in here
 as well.</p>

 <p> Here's some information on the original LBFGS Fortran source code,
 available at <a href="http://www.netlib.org/opt/lbfgs_um.shar">
 http://www.netlib.org/opt/lbfgs_um.shar</a>. This info is taken
 verbatim from the Netlib blurb on the Fortran source.</p>

 <pre>
        file    opt/lbfgs_um.shar
        for     unconstrained optimization problems
        alg     limited memory BFGS method
        by      J. Nocedal
        contact nocedal@eecs.nwu.edu
        ref     D. C. Liu and J. Nocedal, ``On the limited memory BFGS method for
        ,       large scale optimization methods'' Mathematical Programming 45
        ,       (1989), pp. 503-528.
        ,       (Postscript file of this paper is available via anonymous ftp
        ,       to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_um.)
 </pre>
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Jorge Nocedal: original Fortran version, including comments
 (July 1990). Robert Dodier: Java translation, August 1997.</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../RautSoft/math/nlp/LBFGS.ExceptionWithIflag.html" title="class in RautSoft.math.nlp">LBFGS.ExceptionWithIflag</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specialized exception class for LBFGS; contains the
 <code>iflag</code> value returned by <code>lbfgs</code>.</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../RautSoft/math/nlp/LBFGS.html#gtol">gtol</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controls the accuracy of the line search <code>mcsrch</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../RautSoft/math/nlp/LBFGS.html#solution_cache">solution_cache</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The solution vector as it was at the end of the most recently
 completed line search.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../RautSoft/math/nlp/LBFGS.html#stpmax">stpmax</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify upper bound for the step in the line search.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../RautSoft/math/nlp/LBFGS.html#stpmin">stpmin</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify lower bound for the step in the line search.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../RautSoft/math/nlp/LBFGS.html#LBFGS()">LBFGS</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../RautSoft/math/nlp/LBFGS.html#daxpy(int, double, double[], int, int, double[], int, int)">daxpy</A></B>(int&nbsp;n,
      double&nbsp;da,
      double[]&nbsp;dx,
      int&nbsp;ix0,
      int&nbsp;incx,
      double[]&nbsp;dy,
      int&nbsp;iy0,
      int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the sum of a vector times a scalara plus another vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../RautSoft/math/nlp/LBFGS.html#ddot(int, double[], int, int, double[], int, int)">ddot</A></B>(int&nbsp;n,
     double[]&nbsp;dx,
     int&nbsp;ix0,
     int&nbsp;incx,
     double[]&nbsp;dy,
     int&nbsp;iy0,
     int&nbsp;incy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the dot product of two vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../RautSoft/math/nlp/LBFGS.html#lb1(int[], int, int, double, int, int, double[], double, double[], double[], boolean)">lb1</A></B>(int[]&nbsp;iprint,
    int&nbsp;iter,
    int&nbsp;nfun,
    double&nbsp;gnorm,
    int&nbsp;n,
    int&nbsp;m,
    double[]&nbsp;x,
    double&nbsp;f,
    double[]&nbsp;g,
    double[]&nbsp;stp,
    boolean&nbsp;finish)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print debugging and status messages for <code>lbfgs</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../RautSoft/math/nlp/LBFGS.html#lbfgs(int, int, double[], double, double[], boolean, double[], int[], double, double, int[])">lbfgs</A></B>(int&nbsp;n,
      int&nbsp;m,
      double[]&nbsp;x,
      double&nbsp;f,
      double[]&nbsp;g,
      boolean&nbsp;diagco,
      double[]&nbsp;diag,
      int[]&nbsp;iprint,
      double&nbsp;eps,
      double&nbsp;xtol,
      int[]&nbsp;iflag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This subroutine solves the unconstrained minimization problem</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../RautSoft/math/nlp/LBFGS.html#nfevaluations()">nfevaluations</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method returns the total number of evaluations of the objective
 function since the last time LBFGS was restarted.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="gtol"><!-- --></A><H3>
gtol</H3>
<PRE>
public static double <B>gtol</B></PRE>
<DL>
<DD>Controls the accuracy of the line search <code>mcsrch</code>. If the
 function and gradient evaluations are inexpensive with respect
 to the cost of the iteration (which is sometimes the case when
 solving very large problems) it may be advantageous to set <code>gtol</code>
 to a small value. A typical small value is 0.1.  Restriction:
 <code>gtol</code> should be greater than 1e-4.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="stpmin"><!-- --></A><H3>
stpmin</H3>
<PRE>
public static double <B>stpmin</B></PRE>
<DL>
<DD>Specify lower bound for the step in the line search.
 The default value is 1e-20. This value need not be modified unless
 the exponent is too large for the machine being used, or unless
 the problem is extremely badly scaled (in which case the exponent
 should be increased).
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="stpmax"><!-- --></A><H3>
stpmax</H3>
<PRE>
public static double <B>stpmax</B></PRE>
<DL>
<DD>Specify upper bound for the step in the line search.
 The default value is 1e20. This value need not be modified unless
 the exponent is too large for the machine being used, or unless
 the problem is extremely badly scaled (in which case the exponent
 should be increased).
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="solution_cache"><!-- --></A><H3>
solution_cache</H3>
<PRE>
public static double[] <B>solution_cache</B></PRE>
<DL>
<DD>The solution vector as it was at the end of the most recently
 completed line search. This will usually be different from the
 return value of the parameter <tt>x</tt> of <tt>lbfgs</tt>, which
 is modified by line-search steps. A caller which wants to stop the
 optimization iterations before <tt>LBFGS.lbfgs</tt> automatically stops
 (by reaching a very small gradient) should copy this vector instead
 of using <tt>x</tt>. When <tt>LBFGS.lbfgs</tt> automatically stops,
 then <tt>x</tt> and <tt>solution_cache</tt> are the same.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="LBFGS()"><!-- --></A><H3>
LBFGS</H3>
<PRE>
public <B>LBFGS</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="nfevaluations()"><!-- --></A><H3>
nfevaluations</H3>
<PRE>
public static int <B>nfevaluations</B>()</PRE>
<DL>
<DD>This method returns the total number of evaluations of the objective
 function since the last time LBFGS was restarted. The total number of function
 evaluations increases by the number of evaluations required for the
 line search; the total is only increased after a successful line search.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lbfgs(int, int, double[], double, double[], boolean, double[], int[], double, double, int[])"><!-- --></A><H3>
lbfgs</H3>
<PRE>
public static void <B>lbfgs</B>(int&nbsp;n,
                         int&nbsp;m,
                         double[]&nbsp;x,
                         double&nbsp;f,
                         double[]&nbsp;g,
                         boolean&nbsp;diagco,
                         double[]&nbsp;diag,
                         int[]&nbsp;iprint,
                         double&nbsp;eps,
                         double&nbsp;xtol,
                         int[]&nbsp;iflag)
                  throws <A HREF="../../../RautSoft/math/nlp/LBFGS.ExceptionWithIflag.html" title="class in RautSoft.math.nlp">LBFGS.ExceptionWithIflag</A></PRE>
<DL>
<DD>This subroutine solves the unconstrained minimization problem
 <pre>
     min f(x),    x = (x1,x2,...,x_n),
 </pre>
 using the limited-memory BFGS method. The routine is especially
 effective on problems involving a large number of variables. In
 a typical iteration of this method an approximation <code>Hk</code> to the
 inverse of the Hessian is obtained by applying <code>m</code> BFGS updates to
 a diagonal matrix <code>Hk0</code>, using information from the previous M steps.
 The user specifies the number <code>m</code>, which determines the amount of
 storage required by the routine. The user may also provide the
 diagonal matrices <code>Hk0</code> if not satisfied with the default choice.
 The algorithm is described in "On the limited memory BFGS method
 for large scale optimization", by D. Liu and J. Nocedal,
 Mathematical Programming B 45 (1989) 503-528.

 The user is required to calculate the function value <code>f</code> and its
 gradient <code>g</code>. In order to allow the user complete control over
 these computations, reverse  communication is used. The routine
 must be called repeatedly under the control of the parameter
 <code>iflag</code>.

 The steplength is determined at each iteration by means of the
 line search routine <code>mcsrch</code>, which is a slight modification of
 the routine <code>CSRCH</code> written by More' and Thuente.

 The only variables that are machine-dependent are <code>xtol</code>,
 <code>stpmin</code> and <code>stpmax</code>.

        Progress messages are printed to <code>System.out</code>, and
 non-fatal error messages are printed to <code>System.err</code>.
 Fatal errors cause exception to be thrown, as listed below.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - The number of variables in the minimization problem.
                Restriction: <code>n &gt; 0</code>.<DD><CODE>m</CODE> - The number of corrections used in the BFGS update.
                Values of <code>m</code> less than 3 are not recommended;
                large values of <code>m</code> will result in excessive
                computing time. <code>3 &lt;= m &lt;= 7</code> is recommended.
                Restriction: <code>m &gt; 0</code>.<DD><CODE>x</CODE> - On initial entry this must be set by the user to the values
                of the initial estimate of the solution vector. On exit with
                <code>iflag = 0</code>, it contains the values of the variables
                at the best point found (usually a solution).<DD><CODE>f</CODE> - Before initial entry and on a re-entry with <code>iflag = 1</code>,
                it must be set by the user to contain the value of the function
                <code>f</code> at the point <code>x</code>.<DD><CODE>g</CODE> - Before initial entry and on a re-entry with <code>iflag = 1</code>,
                it must be set by the user to contain the components of the
                gradient <code>g</code> at the point <code>x</code>.<DD><CODE>diagco</CODE> - Set this to <code>true</code> if the user  wishes to
                provide the diagonal matrix <code>Hk0</code> at each iteration.
                Otherwise it should be set to <code>false</code> in which case
                <code>lbfgs</code> will use a default value described below. If
                <code>diagco</code> is set to <code>true</code> the routine will
                return at each iteration of the algorithm with <code>iflag = 2</code>,
                and the diagonal matrix <code>Hk0</code> must be provided in
                the array <code>diag</code>.<DD><CODE>diag</CODE> - If <code>diagco = true</code>, then on initial entry or on
                re-entry with <code>iflag = 2</code>, <code>diag</code>
                must be set by the user to contain the values of the
                diagonal matrix <code>Hk0</code>. Restriction: all elements of
                <code>diag</code> must be positive.<DD><CODE>iprint</CODE> - Specifies output generated by <code>lbfgs</code>.
                <code>iprint[0]</code> specifies the frequency of the output:
                <ul>
                <li> <code>iprint[0] &lt; 0</code>: no output is generated,
                <li> <code>iprint[0] = 0</code>: output only at first and last iteration,
                <li> <code>iprint[0] &gt; 0</code>: output every <code>iprint[0]</code> iterations.
                </ul>

                <code>iprint[1]</code> specifies the type of output generated:
                <ul>
                <li> <code>iprint[1] = 0</code>: iteration count, number of function
                        evaluations, function value, norm of the gradient, and steplength,
                <li> <code>iprint[1] = 1</code>: same as <code>iprint[1]=0</code>, plus vector of
                        variables and  gradient vector at the initial point,
                <li> <code>iprint[1] = 2</code>: same as <code>iprint[1]=1</code>, plus vector of
                        variables,
                <li> <code>iprint[1] = 3</code>: same as <code>iprint[1]=2</code>, plus gradient vector.
                </ul><DD><CODE>eps</CODE> - Determines the accuracy with which the solution
                is to be found. The subroutine terminates when
                <pre>
            ||G|| &lt; EPS max(1,||X||),
                </pre>
                where <code>||.||</code> denotes the Euclidean norm.<DD><CODE>xtol</CODE> - An estimate of the machine precision (e.g. 10e-16 on a
                SUN station 3/60). The line search routine will terminate if the
                relative width of the interval of uncertainty is less than
                <code>xtol</code>.<DD><CODE>iflag</CODE> - This must be set to 0 on initial entry to <code>lbfgs</code>.
                A return with <code>iflag &lt; 0</code> indicates an error,
                and <code>iflag = 0</code> indicates that the routine has
                terminated without detecting errors. On a return with
                <code>iflag = 1</code>, the user must evaluate the function
                <code>f</code> and gradient <code>g</code>. On a return with
                <code>iflag = 2</code>, the user must provide the diagonal matrix
                <code>Hk0</code>.

                The following negative values of <code>iflag</code>, detecting an error,
                are possible:
                <ul>
                <li> <code>iflag = -1</code> The line search routine
                        <code>mcsrch</code> failed. One of the following messages
                        is printed:
                        <ul>
                        <li> Improper input parameters.
                        <li> Relative width of the interval of uncertainty is at
                                most <code>xtol</code>.
                        <li> More than 20 function evaluations were required at the
                                present iteration.
                        <li> The step is too small.
                        <li> The step is too large.
                        <li> Rounding errors prevent further progress. There may not
                                be  a step which satisfies the sufficient decrease and
                                curvature conditions. Tolerances may be too small.
                        </ul>
                <li><code>iflag = -2</code> The i-th diagonal element of the diagonal inverse
                        Hessian approximation, given in DIAG, is not positive.
                <li><code>iflag = -3</code> Improper input parameters for LBFGS
                        (<code>n</code> or <code>m</code> are not positive).
                </ul>
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../RautSoft/math/nlp/LBFGS.ExceptionWithIflag.html" title="class in RautSoft.math.nlp">LBFGS.ExceptionWithIflag</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="lb1(int[], int, int, double, int, int, double[], double, double[], double[], boolean)"><!-- --></A><H3>
lb1</H3>
<PRE>
public static void <B>lb1</B>(int[]&nbsp;iprint,
                       int&nbsp;iter,
                       int&nbsp;nfun,
                       double&nbsp;gnorm,
                       int&nbsp;n,
                       int&nbsp;m,
                       double[]&nbsp;x,
                       double&nbsp;f,
                       double[]&nbsp;g,
                       double[]&nbsp;stp,
                       boolean&nbsp;finish)</PRE>
<DL>
<DD>Print debugging and status messages for <code>lbfgs</code>.
 Depending on the parameter <code>iprint</code>, this can include
 number of function evaluations, current function value, etc.
 The messages are output to <code>System.out</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>iprint</CODE> - Specifies output generated by <code>lbfgs</code>.<p>
                <code>iprint[0]</code> specifies the frequency of the output:
                <ul>
                <li> <code>iprint[0] &lt; 0</code>: no output is generated,
                <li> <code>iprint[0] = 0</code>: output only at first and last iteration,
                <li> <code>iprint[0] &gt; 0</code>: output every <code>iprint[0]</code> iterations.
                </ul><p>

                <code>iprint[1]</code> specifies the type of output generated:
                <ul>
                <li> <code>iprint[1] = 0</code>: iteration count, number of function
                        evaluations, function value, norm of the gradient, and steplength,
                <li> <code>iprint[1] = 1</code>: same as <code>iprint[1]=0</code>, plus vector of
                        variables and  gradient vector at the initial point,
                <li> <code>iprint[1] = 2</code>: same as <code>iprint[1]=1</code>, plus vector of
                        variables,
                <li> <code>iprint[1] = 3</code>: same as <code>iprint[1]=2</code>, plus gradient vector.
                </ul><DD><CODE>iter</CODE> - Number of iterations so far.<DD><CODE>nfun</CODE> - Number of function evaluations so far.<DD><CODE>gnorm</CODE> - Norm of gradient at current solution <code>x</code>.<DD><CODE>n</CODE> - Number of free parameters.<DD><CODE>m</CODE> - Number of corrections kept.<DD><CODE>x</CODE> - Current solution.<DD><CODE>f</CODE> - Function value at current solution.<DD><CODE>g</CODE> - Gradient at current solution <code>x</code>.<DD><CODE>stp</CODE> - Current stepsize.<DD><CODE>finish</CODE> - Whether this method should print the ``we're done'' message.</DL>
</DD>
</DL>
<HR>

<A NAME="daxpy(int, double, double[], int, int, double[], int, int)"><!-- --></A><H3>
daxpy</H3>
<PRE>
public static void <B>daxpy</B>(int&nbsp;n,
                         double&nbsp;da,
                         double[]&nbsp;dx,
                         int&nbsp;ix0,
                         int&nbsp;incx,
                         double[]&nbsp;dy,
                         int&nbsp;iy0,
                         int&nbsp;incy)</PRE>
<DL>
<DD>Compute the sum of a vector times a scalara plus another vector.
 Adapted from the subroutine <code>daxpy</code> in <code>lbfgs.f</code>.
 There could well be faster ways to carry out this operation; this
 code is a straight translation from the Fortran.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="ddot(int, double[], int, int, double[], int, int)"><!-- --></A><H3>
ddot</H3>
<PRE>
public static double <B>ddot</B>(int&nbsp;n,
                          double[]&nbsp;dx,
                          int&nbsp;ix0,
                          int&nbsp;incx,
                          double[]&nbsp;dy,
                          int&nbsp;iy0,
                          int&nbsp;incy)</PRE>
<DL>
<DD>Compute the dot product of two vectors.
 Adapted from the subroutine <code>ddot</code> in <code>lbfgs.f</code>.
 There could well be faster ways to carry out this operation; this
 code is a straight translation from the Fortran.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
RautSoft Economics and Business Numerics</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../RautSoft/math/nlp/DonlpJava.html" title="class in RautSoft.math.nlp"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../RautSoft/math/nlp/LBFGS.ExceptionWithIflag.html" title="class in RautSoft.math.nlp"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?RautSoft/math/nlp/LBFGS.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="LBFGS.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
RautSoft
</BODY>
</HTML>
